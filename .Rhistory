mutate(
roil = (oil - lag(oil, order_by = date))/lag(oil, order_by = date))
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/MET4 H21/Hjemmeeksamen trening/hjemme-19-h-ekstra")
read_excel("Oljepriser.xlsx", sheet = 2, skip = 2) %>%
oil = as.Oil(Europe Brent Spot Price FOB (Dollars per Barrel)) %>%
oil = (Europe Brent Spot Price FOB (Dollars per Barrel)) %>%
oil <-
transmute(date = as.Date(Date),
install.packages("readxl")
install.packages("readxl")
install.packages("readxl")
install.packages("readxl")
options("device")
options("device")
options("device")
library(ggplot2)      # For plotting
library(tidyr)        # For pivot_longer() and pivot_wider()
library(readr)        # For reading csv
library(dplyr)        # For pipe etc.
library(patchwork)
temps <- read_csv("data-temps.csv")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/Lectures/Lecture 3")
library(ggplot2)      # For plotting
library(tidyr)        # For pivot_longer() and pivot_wider()
library(readr)        # For reading csv
library(dplyr)        # For pipe etc.
library(patchwork)
temps <- read_csv("data-temps.csv")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/Lectures/Lecture 3")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/Lectures/Lecture 3")
library(ggplot2)      # For plotting
library(tidyr)        # For pivot_longer() and pivot_wider()
library(readr)        # For reading csv
library(dplyr)        # For pipe etc.
library(patchwork)
temps <- read_csv("data-temps.csv")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/Lectures/Lecture 3")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/Lectures/Lecture 3")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/Lectures/Lecture 3")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/R/Lecture 3")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/R/Lecture 3")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/Lectures/Lecture 3")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/Lectures/Lecture 3")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Masterfag/BAN400/Lectures/Lecture 3")
library(ggplot2)      # For plotting
library(tidyr)        # For pivot_longer() and pivot_wider()
library(readr)        # For reading csv
library(dplyr)        # For pipe etc.
install.packages("mmtable2")
library(patchwork)
temps <- read_csv("data-temps.csv")
library(ggplot2)      # For plotting
library(tidyr)        # For pivot_longer() and pivot_wider()
library(readr)        # For reading csv
library(dplyr)        # For pipe etc.
install.packages("mmtable2")
library(patchwork)
temps <- read_csv("data-temps.csv")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Skrivebord/BAN400/Assignment 3")
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Skrivebord/BAN400")
# Assignment 3 ----------
# Load packages ----------
library(ggplot2)
library(dplyr)
library(readr)
# Read in data -----------
plastic <-
read_csv("data/data-plastic.csv") %>%
filter(if_all(c(region, gdp, per_capita_mismanaged, population, region),
~!is.na(.x)))
setwd("C:/Users/marti/OneDrive - Norges Handelshøyskole/Skrivebord/BAN400/Assignment 3")
# Load necessary libraries
library(tweedie)
library(ggplot2)
### Problem 1 ###
#### Part 1: Define a function to simulate sample means ####
simulateSampleMean <- function(N, mu = 0, sigma = 1) {
samples <- rnorm(N, mean = mu, sd = sigma)
sample_mean <- mean(samples)
return(sample_mean)
}
#### Part 2: Simulate sample means and calculate standard deviation ####
M <- 20
sample_means <- numeric(M)
N <- 100  # You can change this as desired
for (i in 1:M) {
sample_means[i] <- simulateSampleMean(N)
}
sample_means_sd <- sd(sample_means)
print("Problem 1 - Part 2 Result:")
print(sample_means_sd)
#### Part 3: Create a table and compare with theoretical value ####
sample_sizes <- seq(10, 200, by = 10)
results <- data.frame(N = sample_sizes, st_dev = numeric(length(sample_sizes)))
sigma <- 1  # You can change this as desired
for (i in 1:length(sample_sizes)) {
N <- sample_sizes[i]
sample_means <- replicate(M, simulateSampleMean(N, sigma = sigma))
results[i, "st_dev"] <- sd(sample_means)
}
results$theoretical <- sigma / sqrt(sample_sizes)
print("Problem 1 - Part 3 Result:")
print(results)
ggplot(results, aes(x = N)) +
geom_line(aes(y = st_dev, color = "Observed")) +
geom_line(aes(y = theoretical, color = "Theoretical")) +
labs(x = "Sample Size (N)", y = "Standard Deviation") +
scale_color_manual(values = c("Observed" = "blue", "Theoretical" = "red")) +
theme_minimal()
### Problem 2 ###
#### Part 1: Define a function to simulate a tweedie-distributed dataset and perform t-test ####
simTweedieTest <- function(N) {
true_mu <- 10000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t_test_result <- t.test(sample, mu = true_mu)
p_value <- t_test_result$p.value
return(p_value)
}
#### Part 2: Define a function to perform multiple t-tests ####
MTweedieTests <- function(M, N, alpha) {
p_values <- replicate(M, simTweedieTest(N))
rejection_rate <- mean(p_values < alpha)
return(rejection_rate)
}
#### Part 3: Perform a simulation experiment and create a plot ####
results <- data.frame(N = c(10, 100, 1000, 5000), M = 100, share_reject = NA)
alpha <- 0.05
for (i in 1:nrow(results)) {
results[i, "share_reject"] <- MTweedieTests(results$M[i], results$N[i], alpha)
}
print("Problem 2 - Part 3 Result:")
print(results)
ggplot(results, aes(x = N, y = share_reject)) +
geom_line() +
labs(x = "Sample Size (N)", y = "Rejection Rate") +
theme_minimal() +
ggtitle("Rejection Rate of t-test for Tweedie-Distributed Data")
# Load necessary libraries
library(tweedie)
library(ggplot2)
### Problem 1 ###
#### Part 1: Define a function to simulate sample means ####
simulateSampleMean <- function(N, mu = 0, sigma = 1) {
samples <- rnorm(N, mean = mu, sd = sigma)
sample_mean <- mean(samples)
return(sample_mean)
}
#### Part 2: Simulate sample means and calculate standard deviation ####
M <- 20
sample_means <- numeric(M)
N <- 100  # You can change this as desired
for (i in 1:M) {
sample_means[i] <- simulateSampleMean(N)
}
sample_means_sd <- sd(sample_means)
print("Problem 1 - Part 2 Result:")
print(sample_means_sd)
#### Part 3: Create a table and compare with theoretical value ####
sample_sizes <- seq(10, 200, by = 10)
results <- data.frame(N = sample_sizes, st_dev = numeric(length(sample_sizes)))
sigma <- 1  # You can change this as desired
for (i in 1:length(sample_sizes)) {
N <- sample_sizes[i]
sample_means <- replicate(M, simulateSampleMean(N, sigma = sigma))
results[i, "st_dev"] <- sd(sample_means)
}
results$theoretical <- sigma / sqrt(sample_sizes)
print("Problem 1 - Part 3 Result:")
print(results)
ggplot(results, aes(x = N)) +
geom_line(aes(y = st_dev, color = "Observed")) +
geom_line(aes(y = theoretical, color = "Theoretical")) +
labs(x = "Sample Size (N)", y = "Standard Deviation") +
scale_color_manual(values = c("Observed" = "blue", "Theoretical" = "red")) +
theme_minimal()
### Problem 2 ###
#### Part 1: Define a function to simulate a tweedie-distributed dataset and perform t-test ####
simTweedieTest <- function(N) {
true_mu <- 10000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t_test_result <- t.test(sample, mu = true_mu)
p_value <- t_test_result$p.value
return(p_value)
}
#### Part 2: Define a function to perform multiple t-tests ####
MTweedieTests <- function(M, N, alpha) {
p_values <- replicate(M, simTweedieTest(N))
rejection_rate <- mean(p_values < alpha)
return(rejection_rate)
}
#### Part 3: Perform a simulation experiment and create a plot ####
results <- data.frame(N = c(10, 100, 1000, 5000), M = 100, share_reject = NA)
alpha <- 0.05
for (i in 1:nrow(results)) {
results[i, "share_reject"] <- MTweedieTests(results$M[i], results$N[i], alpha)
}
print("Problem 2 - Part 3 Result:")
print(results)
ggplot(results, aes(x = N, y = share_reject)) +
geom_line() +
labs(x = "Sample Size (N)", y = "Rejection Rate") +
theme_minimal() +
ggtitle("Rejection Rate of t-test for Tweedie-Distributed Data")
# Load necessary libraries
library(tweedie)
library(ggplot2)
### Problem 1 ###
#### Part 1: Define a function to simulate sample means ####
simulateSampleMean <- function(N, mu = 0, sigma = 1) {
samples <- rnorm(N, mean = mu, sd = sigma)
sample_mean <- mean(samples)
return(sample_mean)
}
#### Part 2: Simulate sample means and calculate standard deviation ####
M <- 20
sample_means <- numeric(M)
N <- 100  # You can change this as desired
for (i in 1:M) {
sample_means[i] <- simulateSampleMean(N)
}
sample_means_sd <- sd(sample_means)
print("Problem 1 - Part 2 Result:")
print(sample_means_sd)
#### Part 3: Create a table and compare with theoretical value ####
sample_sizes <- seq(10, 200, by = 10)
results <- data.frame(N = sample_sizes, st_dev = numeric(length(sample_sizes)))
sigma <- 1  # You can change this as desired
for (i in 1:length(sample_sizes)) {
N <- sample_sizes[i]
sample_means <- replicate(M, simulateSampleMean(N, sigma = sigma))
results[i, "st_dev"] <- sd(sample_means)
}
results$theoretical <- sigma / sqrt(sample_sizes)
print("Problem 1 - Part 3 Result:")
print(results)
ggplot(results, aes(x = N)) +
geom_line(aes(y = st_dev, color = "Observed")) +
geom_line(aes(y = theoretical, color = "Theoretical")) +
labs(x = "Sample Size (N)", y = "Standard Deviation") +
scale_color_manual(values = c("Observed" = "blue", "Theoretical" = "red")) +
theme_minimal()
### Problem 2 ###
#### Part 1: Define a function to simulate a tweedie-distributed dataset and perform t-test ####
simTweedieTest <- function(N) {
true_mu <- 10000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t_test_result <- t.test(sample, mu = true_mu)
p_value <- t_test_result$p.value
return(p_value)
}
#### Part 2: Define a function to perform multiple t-tests ####
MTweedieTests <- function(M, N, alpha) {
p_values <- replicate(M, simTweedieTest(N))
rejection_rate <- mean(p_values < alpha)
return(rejection_rate)
}
#### Part 3: Perform a simulation experiment and create a plot ####
results <- data.frame(N = c(10, 100, 1000, 5000), M = 100, share_reject = NA)
alpha <- 0.05
for (i in 1:nrow(results)) {
results[i, "share_reject"] <- MTweedieTests(results$M[i], results$N[i], alpha)
}
print("Problem 2 - Part 3 Result:")
print(results)
ggplot(results, aes(x = N, y = share_reject)) +
geom_line() +
labs(x = "Sample Size (N)", y = "Rejection Rate") +
theme_minimal() +
ggtitle("Rejection Rate of t-test for Tweedie-Distributed Data")
# Load necessary libraries
library(tweedie)
library(ggplot2)
### Problem 1 ###
#### Part 1: Define a function to simulate sample means ####
simulateSampleMean <- function(N, mu = 0, sigma = 1) {
samples <- rnorm(N, mean = mu, sd = sigma)
sample_mean <- mean(samples)
return(sample_mean)
}
#### Part 2: Simulate sample means and calculate standard deviation ####
M <- 20
sample_means <- numeric(M)
N <- 100  # You can change this as desired
for (i in 1:M) {
sample_means[i] <- simulateSampleMean(N)
}
sample_means_sd <- sd(sample_means)
print("Problem 1 - Part 2 Result:")
print(sample_means_sd)
#### Part 3: Create a table and compare with theoretical value ####
sample_sizes <- seq(10, 200, by = 10)
results <- data.frame(N = sample_sizes, st_dev = numeric(length(sample_sizes)))
sigma <- 1  # You can change this as desired
for (i in 1:length(sample_sizes)) {
N <- sample_sizes[i]
sample_means <- replicate(M, simulateSampleMean(N, sigma = sigma))
results[i, "st_dev"] <- sd(sample_means)
}
results$theoretical <- sigma / sqrt(sample_sizes)
print("Problem 1 - Part 3 Result:")
print(results)
ggplot(results, aes(x = N)) +
geom_line(aes(y = st_dev, color = "Observed")) +
geom_line(aes(y = theoretical, color = "Theoretical")) +
labs(x = "Sample Size (N)", y = "Standard Deviation") +
scale_color_manual(values = c("Observed" = "blue", "Theoretical" = "red")) +
theme_minimal()
### Problem 2 ###
#### Part 1: Define a function to simulate a tweedie-distributed dataset and perform t-test ####
simTweedieTest <- function(N) {
true_mu <- 10000
sample <- rtweedie(N, mu = true_mu, phi = 1000, power = 1.9)
t_test_result <- t.test(sample, mu = true_mu)
p_value <- t_test_result$p.value
return(p_value)
}
#### Part 2: Define a function to perform multiple t-tests ####
MTweedieTests <- function(M, N, alpha) {
p_values <- replicate(M, simTweedieTest(N))
rejection_rate <- mean(p_values < alpha)
return(rejection_rate)
}
#### Part 3: Perform a simulation experiment and create a plot ####
results <- data.frame(N = c(10, 100, 1000, 5000), M = 100, share_reject = NA)
alpha <- 0.05
for (i in 1:nrow(results)) {
results[i, "share_reject"] <- MTweedieTests(results$M[i], results$N[i], alpha)
}
print("Problem 2 - Part 3 Result:")
print(results)
ggplot(results, aes(x = N, y = share_reject)) +
geom_line() +
labs(x = "Sample Size (N)", y = "Rejection Rate") +
theme_minimal() +
ggtitle("Rejection Rate of t-test for Tweedie-Distributed Data")
library(httr)
library(jsonlite)
library(ggplot2)
library(DescTools)
library(tidyverse)
library(magrittr)
library(rlang)
library(lubridate)
library(anytime)
library(readr)
library(yaml)
#### 1: Beginning of script
# Load function for posting GQL-queries and retrieving data:
source("functions/GQL_function.r")
#### 1: Beginning of script
# Load function for posting GQL-queries and retrieving data:
source("functions/GQL_function.r")
#### 1: Beginning of script
# Load function for posting GQL-queries and retrieving data:
source("functions/GQL_function.r")
#### 1: Beginning of script
# Load function for posting GQL-queries and retrieving data:
source("functions/GQL_function.r")
#### 1: Beginning of script
# Load function for posting GQL-queries and retrieving data:
source("functions/GQL_function.r")
setwd("C:/Cdisk_Masterfag/BAN400/Assignment 6 - Iterations/iterations-S195009")
transform_volumes(test)
#### 1: Beginning of script
# Load function for posting GQL-queries and retrieving data:
source("functions/GQL_function.r")
# The URL we will use is stored below:
configs <-
read_yaml("vegvesen_configs.yml")
#### 1: Beginning of script
# Load function for posting GQL-queries and retrieving data:
source("functions/GQL_function.r")
# The URL we will use is stored below:
configs <-
read_yaml("vegvesen_configs.yml")
gql_metadata_qry <- read_file("gql-queries/station_metadata.gql")
library(jsonlite)
library(ggplot2)
library(DescTools)
library(tidyverse)
library(magrittr)
library(rlang)
library(lubridate)
library(anytime)
library(readr)
library(yaml)
#### 1: Beginning of script
# Load function for posting GQL-queries and retrieving data:
source("functions/GQL_function.r")
# The URL we will use is stored below:
configs <-
read_yaml("vegvesen_configs.yml")
gql_metadata_qry <- read_file("gql-queries/station_metadata.gql")
# Let's try submitting the query:
stations_metadata <-
GQL(
query=gql_metadata_qry,
.url = configs$vegvesen_url
)
#### 2: Transforming metadata
source("functions/data_transformations.r")
source("functions/data_tests.r")
test_stations_metadata(stations_metadata_df)
#### 3: Testing metadata
source("functions/data_tests.r")
test_stations_metadata(stations_metadata_df)
#### 3: Testing metadata
source("functions/data_tests.r")
test_stations_metadata(stations_metadata)
source("functions/data_transformations.r")
source("functions/data_transformations.r")
library(httr)
library(jsonlite)
library(ggplot2)
library(DescTools)
library(tidyverse)
library(magrittr)
library(rlang)
library(lubridate)
library(anytime)
library(readr)
library(yaml)
stations_metadata_df <-
stations_metadata %>%
transform_metadata_to_df(.)
#### 3: Testing metadata
source("functions/data_tests.r")
test_stations_metadata(stations_metadata)
#### 3: Testing metadata
source("functions/data_tests.r")
test_stations_metadata(stations_metadata)
#### 3: Testing metadata
source("functions/data_tests.r")
test_stations_metadata(stations_metadata)
View(stations_metadata_df)
stations_metadata <-
stations_metadata %>%
transform_metadata_to_df(.)
View(stations_metadata_df)
View(stations_metadata_df)
View(stations_metadata)
#### 3: Testing metadata
source("functions/data_tests.r")
test_stations_metadata(stations_metadata)
rm(stations_metadata_df)
source("gql-queries/vol_qry.r")
to_iso8601 <- function(datetime, offset_days) {
# Adding offset to the original datetime
adjusted_datetime <- datetime + lubridate::days(offset_days)
# Convert to ISO8601 format
iso_datetime <- format(adjusted_datetime, format = "%Y-%m-%dT%H:%M:%SZ")
return(iso_datetime)
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
library(httr)
library(jsonlite)
library(ggplot2)
library(DescTools)
library(tidyverse)
library(magrittr)
library(rlang)
library(lubridate)
library(anytime)
library(readr)
library(yaml)
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
source("functions/data_transformations.r")
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
source("functions/data_transformations.r")
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
source("functions/data_transformations.r")
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
source("functions/data_transformations.r")
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
source("functions/data_transformations.r")
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
to_iso8601 <- function(datetime, offset){
# Convert the input datetime to a datetime object with UTC timezone.
datetime <- as_datetime(datetime, tz = "UTC")
# Ensure successful conversion of input datetime.
if(is.na(datetime)) stop("Datetime conversion failed for input: ", datetime)
# Apply the specified offset in days to the datetime.
offset_datetime <- datetime + lubridate::days(offset)
# Check that the offset does not lead to an invalid datetime.
if(is.na(offset_datetime)) stop("Offset results in an invalid datetime for input: ", datetime)
# Convert the offset datetime to ISO8601 format with "Z" indicating UTC timezone.
time <- paste0(anytime::iso8601(offset_datetime), "Z")
return(time)
}
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
to_iso8601 <- function(datetime, offset){
# Convert the input datetime to a datetime object with UTC timezone.
datetime <- as_datetime(datetime, tz = "UTC")
# Ensure successful conversion of input datetime.
if(is.na(datetime)) stop("Datetime conversion failed for input: ", datetime)
# Apply the specified offset in days to the datetime.
offset_datetime <- datetime + lubridate::days(offset)
# Check that the offset does not lead to an invalid datetime.
if(is.na(offset_datetime)) stop("Offset results in an invalid datetime for input: ", datetime)
# Convert the offset datetime to ISO8601 format with "Z" indicating UTC timezone.
time <- paste0(anytime::iso8601(offset_datetime), "Z")
return(time)
}
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
to_iso8601(as_datetime("2016-09-01 10:11:12"),0)
to_iso8601(as_datetime("2016-09-01 10:11:12"),-4)
to_iso8601(as_datetime("2016-09-01 10:11:12"),-4)
install.packages(c("anytime", "lubridate"))
install.packages(c("anytime", "lubridate"))
